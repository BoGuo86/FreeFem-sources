include "test.idp"

cout << "adaptmesh" << endl;

real t;

mesh Th = square(5, 5);

fespace Uh(Th, P0);
Uh u, uu;
real hMin = 1;
real hMax = 42.;
real Err = 1.;
real Errg = 1.;
int nbvtx = 42;
int nbSmooth = 21;
int nbJacoby = 21;
real Ratio = 5;
real Omega = 1;
bool Iso = true;
bool AbsError = true;
real cutOff = 10;
real verbos = 1.5;
bool Inquire = true;
bool splitPbEdge = true;
int maxSubDiv = 5;
bool rescal = true;
bool keepBackVertices = true;
bool isMetric = false;
int poweer = 4;
int thetaMax = 90;
int splitInTwo = true;
bool noMeshGeneration = false;
real[int, int] Periodic(3, 3);
// (real[int], real[int], real[int]) Metric;
// real[int] Periodic = [1., 2., 2.];

t = clock();
mesh Thnew = adaptmesh(Th, [u, uu], hmin=hMin, hmax=hMax, err=Err, errg=Errg,
  nbvx=nbvtx, nbsmooth=nbSmooth, nbjacoby=nbJacoby, ratio=Ratio, omega=Omega,
  iso=Iso, abserror=AbsError, cutoff=cutOff, verbosity=verbos, inquire=Inquire,
  splitpbedge=splitPbEdge, maxsubdiv=maxSubDiv, rescaling=rescal,
  keepbackvertices=keepBackVertices, IsMetric=isMetric, power=poweer, thetamax=thetaMax,
  splitin2=splitInTwo, nomeshgeneration=noMeshGeneration);
t = clock() - t;
cout << IND << IND << t << endl;
// plot(Thnew);
test(Thnew.nt != Th.nt);
test(Thnew.nv != Th.nv);
test(Thnew.nbe != Th.nbe);
// test(Thnew.max != Th.max);
