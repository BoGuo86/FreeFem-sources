//ff-mpirun -np 4 htool_bem_ffddm.edp -wg

// for the make check:
// NBPROC 4
// PARAM

load "htool_bem"
load"msh3"
load"gmsh"

include"MeshSurface.idp"
// macro for ffddm
macro dimension 3S// EOM            // 2D or 3D
include "ffddm.idp"
macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P1;  
ffddmprecond="ras";


// generation of meshes
// Domain, the full domain to plot the scattered field (plane domain)
// Sphere the object 

real scale=1;
real l = 3;

border a(t=-l,l){x=t; y=-l;label=1;};
border b(t=-l,l){x=l; y=t;label=1;};
border c(t=l,-l){x=t; y=l;label=1;};
border d(t=l,-l){x=-l; y=t;label=1;};
int n = 100;
border i(t=0,2*pi){x=1.1*cos(t);y=1.1*sin(t);label=5;};
mesh th= buildmesh(a(n)+b(n)+c(n)+d(n)+i(-n));

meshS Domain= movemesh23(th,transfo=[scale*x,scale*y,scale*z]);

meshS Obstacle = Ellipsoide(1,1,1,0.1,0,-1);
Obstacle = movemesh(Obstacle,[scale*x,scale*y,scale*z]);


ffddmbuildDmesh(Hel, Obstacle, mpiCommWorld)
ffddmbuildDfespace(Hel, Hel, complex, def, init, Pk)

HelVhi<complex> u,v;

fespace Uh(Obstacle,P1);
fespace Vh(Domain,P1);
Vh<complex> w,uinc;

Uh<complex> ug;

fespace Uh2(Obstacle,P1);

macro Varf(Uh, Vh)
assemblecomplex(Uh,Uh,eta=10,epsilon=1e-3,minclustersize=10,maxblocksize=1000000)
//

macro VarfPrec(Uh, Vh)
assemblecomplex(Uh,Uh,eta=10,epsilon=1e-3,minclustersize=10,maxblocksize=1000000,comm=Helcommself)
//
  
ffddmsetupOperator(Hel, Hel, Varf)

if (mpirank == 0)
  cout << HelAglobal.infos << endl;
display(HelAglobal);

ffddmsetupPrecond(Hel, VarfPrec)

// incident wave
real[int] dir=[1./sqrt(2),1./sqrt(2),0];
int kappa=10;
func finc = exp(1i*kappa*(x*dir[0]+y*dir[1]+z*dir[2]));
ug = finc;
  
varf vmass(u,v) = int2d(Obstacle)(u*v);
matrix<complex> massg = vmass(Uh,Uh);

// RHS global
complex[int] rhsg = massg*ug[];
rhsg *= -1;
  
complex[int] rhs(HelVhi.ndof);
 
rhs = HelRih[mpirank]*rhsg;

u = 0.;

u[] = HelfGMRES(u[], rhs, 1.e-6, 200, "right");

Helwritesummary

ffddmplot(Hel, real(u), "bem solution");

v[] = HelA(u[]);
	
HelfromVhi(u[], Uh, ug[])

// output visu
HMatrix<complex> B;

B = assemblecomplex(Uh,Vh,eta=10,epsilon=1e-3,minclustersize=10,maxblocksize=1000000,type=1);
if (mpirank == 0)
   cout << B.infos << endl;
display(B);

w[] = B*ug[];
	
uinc = finc;
w[] += uinc[];

//visu of solution in the total domain
// real part  
Vh uplot = real(w); 
plot(uplot);
