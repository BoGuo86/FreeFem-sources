//ff-mpirun -np 4 Helmholtz_circle.edp -wg

// for the make check:
// NBPROC 4
// PARAM

load "htool_bem"
load "msh3"

complex k = 10;

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));
func dxfinc = 1i*k*dir[0]*finc;
func dyfinc = 1i*k*dir[1]*finc;

int n = 1000;

curve3 circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}

meshL Th = buildmesh(circle(n));

fespace Uh(Th,P1);

HMatrix<complex> H = assemblecomplexHEHS(Uh,Uh,k,eta=10,epsilon=1e-2,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << H.infos << endl;
display(H);

Uh<complex> u, b;

//varf vmass(u,v) = int1d(Th)(-finc*v);
varf vmass(u,v) = int1d(Th)((dxfinc*x+dyfinc*y)*v);

b[] = vmass(0,Uh);

u[] = H^-1*b[];

plot(u,dim=2);

int np = 200;

int R = 4;

real r = 1.01;

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}

border b5(t=0, -2*pi){x=r*cos(t); y=r*sin(t);z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+b5(np*pi/R));

fespace UhOut(ThOut,P1);

HMatrix<complex> B = assemblecomplexHEDLPot(Uh,UhOut,k,eta=10,epsilon=1e-2,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> v, vinc;

vinc = finc;

v[] = B*u[];

v[] += vinc[];

UhOut vr = abs(v);

plot(vr, dim=2, fill=1, value=1, nbiso=20);
