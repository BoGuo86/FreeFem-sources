//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

meshN Th = square(1, 1);
fespace Wh(Th, Pk);              // local finite element space
int[int][int] intersection(0);   // local-to-neighbors renumbering
real[int] D;                     // partition of unity
{
    meshN ThBorder;
    Th = square(getARGV("-global", 40), getARGV("-global", 40));    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, mpiCommWorld, false)
}

matrix<real> Mat;                           // local operator
mesh ThCoarse = square(getARGV("-global_coarse", 10), getARGV("-global_coarse", 10));    // global coarse mesh
varf vPb      (u, v) = intN(Th      )(grad(u)' * grad(v)) + intN(Th      )(v) + on(1, u = 1.0);
varf vPbCoarse(u, v) = intN(ThCoarse)(grad(u)' * grad(v)) + intN(ThCoarse)(v) + on(1, u = 1.0);
Mat = vPb(Wh, Wh, tgv = -1);
fespace WhCoarse(ThCoarse, Pk);
matrix MatCoarse = vPbCoarse(WhCoarse, WhCoarse, tgv = -1);
set(MatCoarse, solver = sparsesolver);
matrix R = interpolate(Wh, WhCoarse);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_variant flexible");
func real[int] correction(real[int]& in) {
    real[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    in .*= D;
    tmp = R' * in;
    mpiAllReduce(tmp, tmpReduced, mpiCommWorld, mpiSUM);
    tmp = MatCoarse^-1 * tmpReduced;
    if(!NoGraphicWindow) {
        WhCoarse vis;
        vis[] = tmp;
        plot(vis, wait = 1, value = 1, fill = 1, cmm = "Coarse grid solution");
    }
    out = R * tmp;
    exchange(A, out);
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    attachCoarseOperator(mpiCommWorld, A, correction);
}

Wh<real> def(u);    // local solution

u[] = A^-1 * rhs;

real[int] res = A * u[]; // global matrix-vector product
res -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution")
u[] = res;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual")
